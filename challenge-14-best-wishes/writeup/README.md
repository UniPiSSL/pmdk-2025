# **Best Wishes** Write-Up

| Δοκιμασία | Best Wishes |
| :------- | :----- |
| Δυσκολία | Εύκολη |
| Κατηγορία | Κρυπτογραφία (Cryptography) |
| Λύσεις | 9 |
| Πόντοι | 520 |

- **Difficulty : Easy - 100 points**

# Challenge Overview

## Description

```
TBD
```

## Data

```py
d = 1267867491460789041306340400250556708805898346108295647518652896462472837223550763813601628565360369013077603139691360424978846974610022478092030332559156986159486485993299332116281449464120492181723222827753245582763627110338898411377309419593081392985281605566202007591081516976979509915097037764706746351069015151908903922937830150468697844905637704939520304476657943302466562965641227078897260097671973313434500267826729409217824763156894957328824550623576193
enc_msgs = [1185362292783433383524463719393175489716404899298444631428525892587642939309239117015185563461868938840396380245307157064255668030709534235989918250053103305499952613249137651736828268191163079296412344033160930009910583093380006871403129327143808904882570563114740132953948104529051453883070243060049508364669681311398516457131096885646257869188708630743202533417831912561864667924237339889911306346621107042801805838297044168322086930437732377428170374330470956, 705948755021402509090600902559224302314594608200972750921081811527855049250112359765382809822148038017988053082484028585366636319841992684946458546940351918289722593648124484869203207771989063719937528403332579803041359150372167015453494094793692192131453382972248783205747408294686015924800622836255066732834892563988483446307102384687604550127148527748763358225870861889496321531355488072305506440005172750421814232316527697797544540916351581827290656904229800]
iv = 'af75435821dc8e3bd5fb980a0f467599'
enc_flag = 'ba13c884aedd3b9385d07c81ebec6622e5dd94958611d9c5b3cde41129ff9fea'
```

# Solution

Παρακάτω βλέπουμε τον πηγαίο κώδικα του challenge, σε python:

```python
from secret import FLAG
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, GCD
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from hashlib import sha256

p = getPrime(768)
q = getPrime(768)
e = 65537
n = p * q
phi = (p-1) * (q-1)

d = pow(e, -1, phi)

key = sha256((str(p) + str(q)).encode()).digest()
cipher = AES.new(key, AES.MODE_CBC)
enc_flag = cipher.encrypt(pad(FLAG, 16)).hex()

enc_msgs = [pow(bytes_to_long(m), e, n) for m in [b'Good luck!', b'You need it!']]

iv = cipher.iv.hex()
with open('output.txt', 'w') as f:
    f.write(f'{d = }\n')
    f.write(f'{enc_msgs = }\n')
    f.write(f'{iv = }\n')
    f.write(f'{enc_flag = }\n')
```

Η δομή του πηγαίου κώδικα είναι κοινή σε πολλά crypto CTFs που σχετίζονται με το κρυπτοσύστημα RSA. Στην αρχή υλοποιείται η παραδοσιακή δημιουργία RSA κλειδιών και ύστερα κρυπτογραφείται το flag με AES το οποίο και γράφεται στο `output.txt`. Σκοπός μας είναι να αποκρυπτογραφήσουμε το flag.

Το κλειδί RSA είναι αρκετά μεγάλο και έτσι δεν μπορούμε να εφαρμόσουμε κάποιον αλγόριθμο παραγοντοποίησης σε πρώτους αριθμούς καθώς είναι υπολογιστικά ανέφικτο να παραγοντοποιηθούν αριθμοί μήκους $768 + 768 = 1536$ bits.

Το flag κρυπτογραφήθηκε με AES σε CBC mode. Μας δίνεται το IV καθώς δεν χρειάζεται να είναι κρυφό, σε αντίθεση με το κλειδί από το οποίο εξαρτάται η ασφάλεια της κρυπτογράφησης. Το κλειδί βλέπουμε πως είναι η συνένωση της αλφαριθμητικής μορφής των $p, q$, δηλαδή $p \ || \ q$. Επομένως, για να αποκρυπτογραφήσουμε το flag, πρέπει να βρούμε τα $p, q$, ή αλλιώς να παραγοντοποιήσουμε το $n = p \cdot q$.

Κάποια πράγματα που ξεχωρίζουν από έναν standard RSA είναι οτι τώρα δεν ξέρουμε το modulus $n$ αλλά ξέρουμε το $d$ καθώς και δύο ζευγάρια plaintext/ciphertext. Για να παραγοντοποιήσουμε το $n$, πρέπει πρώτα να ξέρουμε την τιμή του, πάμε λοιπόν να την υπολογίσουμε.

## Ανακτώντας το modulus $n$

Υπενθυμίζεται πως η κρυπτογράφηση RSA έχει την παρακάτω μορφή:

$$C = M^e \pmod N$$

όπου:

- C το κρυπτοκείμενο.
- $M$ το μήνυμα προς κρυπτογράφηση.
- $e$ ο δημόσιος εκθέτης για την κρυπτογράφηση. Σε αυτό το challenge έχει την προεπιλεγμένη τιμή $65537$.
- $Ν$ το modulus.

Αν περάσουμε το $M^e$ από το άλλο μέλος, έχουμε πως:

$$M^e - C = k_1N$$​

Αυτό μας λέει πως η διαφορά στο αριστερό μέλος είναι ένα πολλαπλάσιο του $N$.

Μας δίνονται δύο ζευγάρια $\{M_1, C_1\}$ και $\{M_2, C_2\}$ για τα οποία ισχύει:

$$M_1^e - C_1 = k_1N$$ και

$$M_2^e - C_2 = k_2N$$

Παίρνοντας τον ΜΚΔ των αριστερών μελών, υπολογίζουμε:

$$\text{GCD}(M_1^e - C_1, M_2^e - C_2) = kN$$

όπου $k$ μια μικρή σταθερά την οποία αν απλοποιήσουμε, παίρνουμε την τιμή του $N$.

```python
msgs = [bytes_to_long(b'Good luck!'), bytes_to_long(b'You need it!')]

n = GCD(msgs[0] ** e - enc_msgs[0], msgs[1] ** e - enc_msgs[1])

for i in range(2, 10**5):
		if n % i == 0:
				n //= i

print(f'{n = }')
```

## Παραγοντοποιώντας το modulus $n$

Έχοντας ανακτήσει την τιμή του modulus και γνωρίζοντας το ιδιωτικό κλειδί $d$, μπορούμε να παραγαντοποιήσουμε το $n$ με διάφορες μεθόδους. Η ιδέα περιγράφεται [εδώ](https://math.stackexchange.com/a/1839766). Ας χρησιμοποιήσουμε την συνάρτηση που υπάρχει [εδώ](https://gist.github.com/AntonKueltz/73c28f5a2ceb5f37a3db471068a36a68) για να κάνουμε την παραγοντοποίηση.

Τρέχοντας αυτή την συνάρτηση, βλέπουμε ότι πολύ γρήγορα μας επιστρέφει τα $p,q$. Μετά, γνωρίζοντας το συμμετρικό κλειδί, είναι τετριμμένο να αποκρυπτογραφήσουμε με AES.

# Solver

```python
from Crypto.Util.number import GCD, bytes_to_long, long_to_bytes
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha256

# source : https://gist.github.com/AntonKueltz/73c28f5a2ceb5f37a3db471068a36a68
def factor(n, e, d):
    """http://crypto.stackexchange.com/a/25910/17884
    
    n - modulus
    e - public exponent
    d - private exponent
    returns - (p, q) such that n = p*q
    """
    from random import randint

    while True:
        z = randint(2, n - 2)
        k, x = 0, e * d - 1

        while not x & 1:
            k += 1
            x >>= 1

        t = pow(z, x, n)
        if t == 1 or t == (n-1):
            continue

        bad_z = False
        for _ in range(k):
            u = pow(t, 2, n)

            if u == -1 % n:
                bad_z = True
                break

            if u == 1:
                p = GCD(n, t-1)
                q = GCD(n, t+1)
                assert n == p * q
                return p, q
            else:
                t = u

        if bad_z:
            continue

exec(open('output.txt').read())

e = 65537

msgs = [bytes_to_long(b'Good luck!'), bytes_to_long(b'You need it!')]

n = GCD(msgs[0] ** e - enc_msgs[0], msgs[1] ** e - enc_msgs[1])

for i in range(2, 10**5):
	if n % i == 0:
		n //= i

print(f'{n = }')

p, q = factor(n, e, d)

assert n == p * q

key = sha256((str(p) + str(q)).encode()).digest()
cipher = AES.new(key, AES.MODE_CBC, iv=bytes.fromhex(iv))

print(unpad(cipher.decrypt(bytes.fromhex(enc_flag)), 16))
```

# Flag

```
FLAG{4ny_l34k_1s_s3r10us_l34k!}
```

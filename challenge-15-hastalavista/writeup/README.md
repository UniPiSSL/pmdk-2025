# **Hastalavista** Write-Up

| Δοκιμασία | Hastalavista |
| :------- | :----- |
| Δυσκολία | Μέτρια |
| Κατηγορία | Κρυπτογραφία (Cryptography) |
| Λύσεις | 15 |
| Πόντοι | 355 |

- **Difficulty : Medium - 200 points**

# Challenge Overview

## Description

```
TBD
```

## Data

```python
encs = [4156599988868145736058322847414018665586851717298162373563960169006077390844900355569310084074090517212327119493993290234037442329662407223692504969841956230924560756630481792841309936369102933867986018507649397942830819102713208424922169278581652584541176957206895408672212321179387370697191498282540740459, ..., 89585193513136788285683412908689373529538211808982218683211245132625041153359011183108030472791153339957203967193763222999409568979830566380701792292641235192190290177232456370733275850316800335705325816936289122132230408762610262383165523496318991123762907940367591458428243753271032724732995668832842727152]
N = [147020337482754441295650841291318370823617365067215092848770751670735136882706722044582521855378113584299676506959297968347050288714158930428736044840384973767757298289362811104286146022715865129250838023705516362559596760886507466778501986475342238051009127482106211741771045977027632386421549295963552600879, ..., 127035488605844731104365443286101970698853065738299906555383991529311474055410678798310413626862350625838107392335663288058096337332403852308573913491099190393062603569540704817848011327323398392160755797426741356972788644722804713626756368772141454480835486489978870524476243493080405945294123480491586083551]
```

# Solution

Παρακάτω βλέπουμε τον πηγαίο κώδικα του challenge:

```python
from secret import e, FLAG
from Crypto.Util.number import isPrime, getPrime, bytes_to_long, long_to_bytes, GCD
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from hashlib import sha256
import secrets, random

assert isPrime(e) and not (e-1) & 1 and isPrime(e-1)

E = [e] + [secrets.randbits(16) for _ in range(13)]
random.shuffle(E)

class RSA:
    def __init__(self, bits):
        p = getPrime(bits)
        q = getPrime(bits)
        self.n = p * q

    def encrypt(self, m):
    		c = secrets.choice(E)
    		return pow(m, c, self.n)

RSAs = [RSA(512) for _ in range(65)]

m = bytes_to_long(FLAG)

encs = [rsa.encrypt(m) for rsa in RSAs]
N = [rsa.n for rsa in RSAs]

with open('output.txt', 'w') as f:
    f.write(f'{encs = }\n')
    f.write(f'{N = }')
```

Αρχικά, παρατηρούμε ότι υπάρχει μια κλάση "RSA" η οποία υλοποιεί παραγωγή κλειδιών και κρυπτογράφηση rsa. Δημιουργούνται 65 objects της κλάσης όπου το κάθε modulus είναι 1024 bits συνολικά. Παρ' όλα αυτά, ο δημόσιος εκθέτης $e$, είναι κρυφός. Το μόνο που ξέρουμε για αυτόν είναι το παρακάτω:

```python
assert isPrime(e) and not (e-1) & 1 and isPrime(e-1)
```

Ξέρουμε ότι:

- το $e$ είναι πρώτος
- το $e-1$ είναι άρτιος
- το $e-1$ είναι πρώτος

Ο μόνος άρτιος αριθμός που είναι και πρώτος είναι το 2, επομένως $e = 3$. Το $3$ όμως δεν είναι ο μοναδικός εκθέτης για την κρυπτογράφηση, παράγονται άλλοι 13 τυχαίοι $16$-bit εκθέτες. Στην συνέχεια, η λίστα $E$ με τους 14 εκθέτες ανακατανέμεται και το flag, κρυπτογραφείται 65 φορές, κάθε φορά με διαφορετικό modulus και ως εκθέτης διαλέγεται τυχαία ένας από τους 14 της λίστας $E$​.

Αυτό που πρέπει να παρατηρήσει κάποιος/α για να λύσει το challenge είναι οτι το **ίδιο** μήνυμα κρυπτογραφείται χρησιμοποιώντας διαφορετικά moduli και ένας από τους εκθέτες είναι μικρός αρκετά ώστε να μπορούν να χρησιμοποιηθούν low exponent επιθέσεις στον RSA, όπως το Hastad Broadcast Attack. Για παράδειγμα, για $e = 3$, αυτή η επίθεση λειτουργεί ως:

Δοθέντος:

$$C_1 = M^3 \pmod {N_1} \\ C_2 = M^3 \pmod {N_2} \\ C_3 = M^3 \pmod {N_3}$$

ένας μπορεί να αντιμετωπίσει το $M^3$ σαν έναν άγνωστο και να τον υπολογίσει modulo $N_1N_2N_3$ με χρήση του Κινέζικου Θεωρήματος Υπολοίπων. Μετά, με χρήση τρίτης ρίζας, ανακτάει το $M$.

Σε αυτό το challenge όμως, δεν έχουν προκύψει όλα τα κρυπτοκείμενα από $e = 3$. Χρειαζόμαστε τουλάχιστον 3 φορές από τις 65 να έχει επιλεχθεί το 3 ως εκθέτης για κρυπτογράφηση, κάτι που είναι εξαιρετικά πιθανό. Το μόνο που έχουμε να κάνουμε, είναι να πάρουμε όλους τους πιθανούς συνδυασμούς των κρυπτοκειμένων και των αντίστοιχων moduli, και να εφαρμόσουμε την επίθεση Hastad Broadcast. Θα γνωρίζουμε οτι βρήκαμε την λύση:

- είτε αν το αποκρυπτογραφημένο $M$ περιέχει το flag format `FLAG{`
- είτε αν το $M^3$ που υπολογίσαμε από το κινέζικο θεώρημα υπολοίπων, είναι τέλεια τρίτη ρίζα.

Ευτυχώς, το πλήθος των κρυπτοκειμένων είναι 65 και ο εκθέτης 3 άρα χρειάζεται συνολικά να ψάξουμε, μόλις $\begin{pmatrix}65 \\ 3\end{pmatrix} = 43680$ συνδυασμούς.

# Solver

```python
from itertools import combinations
from gmpy2 import iroot
from sympy.ntheory.modular import crt
from tqdm import tqdm
from Crypto.Util.number import long_to_bytes

e = 3

exec(open('output.txt').read())

for comb in tqdm(combinations(range(len(N)), r=e)):
    selected_N = [N[i] for i in comb]
    selected_encs = [encs[i] for i in comb]
    sol, pr = crt(selected_N, selected_encs)
    m, b = iroot(sol, e)
    if b:
        print(long_to_bytes(m))
        break
```

# Flag

```
FLAG{h4st4d_br04dc4st_4tt4ck_w1th_c0mb1n4t10ns_h4st4d_br04dc4st_4tt4ck_w1th_c0mb1n4t10ns_0123456789!}
```
